---
layout: post
title: "Codechef Challenge Dec20 Editorial"
date:  2020-12-12 20:32:58 +0700
categories: [codechef, algorithm, math, python, problems]
---

<br/>

Below are my solutions to [Codechef December 2020 Challenge](https://www.codechef.com/DEC20A).

<br/>

### Even Pair Sum ([EVENPSUM][EVENPSUM])
Can be done fairly easily in `O(1)` by counting even and odds.

{% highlight python %}
def odd(x):
    return (x + 1) // 2

def even(x):
    return x - odd(x)

tc = int(input())
for t in range(tc):
    a, b = map(int, input().split())
    res = even(a) * even(b) + odd(a) * odd(b)
    print(res)
{% endhighlight %}


✅ [Code](https://www.codechef.com/viewsolution/40096434)

<br/>

### Positive Prefixes ([POSPREFS][POSPREFS])

A simple heuristic would be to just fill numbers alternating `+` and `-`:
```
1 -2 3 -4 5 -6 ...
```
and at any point consider filling the rest with all `-` or all `+`.

✅ [Code](https://www.codechef.com/viewsolution/40097421)

<br/>

### Hail XOR ([HXOR][HXOR])

For each operation, we just use XOR to unset the msb (most significant bit) of the leftmost non-zero number in the list. Since we need to apply this operation to the same bit on another number as well, we pick the next number in the list with that bit set. In order to find the next number with the `i-th` bit set, we can maintain an array where the `i-th` element stores the index of the leftmost number in the list with the `i-th` bit set. As we use XOR to unset that bit, we find the next index and update that element of the array in linear time. In total, the runtime will be `O(N * BITS)`. The two corner cases we need to be careful about are: 1) when all elements are zero except the last element. 2) there is only one number with the `i-th` bit set. For how to handle these details, you can check my code link below.

✅ [Code](https://www.codechef.com/viewsolution/40099576)

<br/>

### Calculus ([CALCULUS][CALCULUS])

I had a lucky/lazy approach to this problem. Assuming $$F(N)$$ is:

$$
\begin{equation}
\begin{aligned}
F(N) &= \int_{0}^{\infty} \dfrac{ e^{2 \pi x} - 1 }{e^{2 \pi x} + 1} \left( \dfrac{1}{x} - \dfrac{x}{N^2 - x^2} \right) \,dx
\end{aligned}
\end{equation}
$$

From the example test case, we know $$ F(1) = 2 $$. Then you can plug in different values of $$ N \in \{2, 3, 4, \cdots \} $$ and use [WolframAlpha](https://www.wolframalpha.com) to find the integral from $$0$$ to $$\infty$$. Here are a few values:

$$
\begin{equation}
\begin{aligned}
F(1) &= 2 \\
F(2) &= 2.\bar6 = 2 + \frac{2}{3}\\
F(3) &= 3.0\bar6 = 2 + \frac{2}{3} + \frac{2}{5} \\
F(4) &= 3.35238 = 2 + \frac{2}{3} + \frac{2}{5} + \frac{2}{7}
\end{aligned}
\end{equation}
$$

So, the solution is simply:

$$
F(N) = \frac{2}{1} + \frac{2}{3} + \frac{2}{5} + \cdots + \frac{2}{2N - 1}
$$

which you can do with a one liner in python:

{% highlight python %}
def solve(n):
    return sum((2 * mod_inv(2 * i + 1, MOD)) % MOD for i in range(n)) % MOD
{% endhighlight %}

✅ [Code](https://www.codechef.com/viewsolution/40242325)

<br/>

### String Operations ([STROPERS][STROPERS])

Since we can reverse any substring with even `1`s in it, a special case is when we have only two `1`s in the string with a zero on the left. Reversing this substring results in a left shift:

$$
01001 \rightarrow 10010
$$

By repeating this operation, in any order, on any given string `s` we get a representative for that class (you can prove it yourself). For example, let's start with the string $$ 0100001100110 $$, we can shift the two leftmost `1`s to the left once : 

$$ 
0\color{magenta}{100001}100110 \\
\color{magenta}{100001}0100110 \\
$$

Then we pick the next pair and shift left:

$$ 
10000\color{magenta}{101}00110 \\
1000\color{magenta}{101}000110 \\
100\color{magenta}{101}0000110 \\
10\color{magenta}{101}00000110 \\
1\color{magenta}{101}000000110 \\
$$

And the next:

$$ 
110\color{magenta}{10000001}10 \\
11\color{magenta}{10000001}010 \\
$$

And the next:

$$ 
111000000\color{magenta}{101}0 \\
11100000\color{magenta}{101}00 \\
1110000\color{magenta}{101}000 \\
111000\color{magenta}{101}0000 \\
11100\color{magenta}{101}00000 \\
1110\color{magenta}{101}000000 \\
111\color{magenta}{101}0000000 \\
$$

Finally we have the representative of the class:

$$
R(0100001100110) = 1111010000000
$$

The representative string will always look like a group of `1`s (potentially none), then a group of `0`s (potentially none), one `1`, a group of zeros (potentially none). So, we can uniquely identify each representative with the triplet: `<num_ones, zeros_between, zeros_after>` or simpler: `<num_ones, zeros_between, string_length>`. However, spending `O(N)` time to calculate the representative would be too slow. Let's see if we can calculate them in `O(1)`.

Notice that each shift operation jumps a `0` over the next two `1`s. So, if we group consecutive zeros and number them from left to right (group 0, group1, group2, etc.), the sum of odd groups will always stay the same under this operation (same with the even groups). So, we can keep track of odd/even zero groups as we encounter them and update our representative in `O(1)` as we iterate through substrings.

Finally, we insert all the representatives we find into a set and at the end we look at the size of the set. Here is the code to solve this problem:

{% highlight python %}
def solve(s):
    classes = set()
    for i in range(len(s)):
        z = [0, 0]
        ones = 0
        cur_par = 0
        for j in range(i, len(s)):
            if s[j] == '1':
                ones += 1
                cur_par = 1 - cur_par
            else:
                z[cur_par] += 1
            L = j - i + 1
            if ones == 0:
                r = 0, L
            else:
                r = ones, z[1 - cur_par], L
            classes.add(r)
    return len(classes)
{% endhighlight %}



✅ [Code](https://www.codechef.com/viewsolution/40275405)

<br/>

### Square Root of LCA Convolution ([LCASQRT][LCASQRT])


✅ [Code](https://www.codechef.com/viewsolution/40350264)

<br/>

### Permutations ([DIVPERMS][DIVPERMS])
- ❌ N/A

### Linear Combination ([MODPARRS][MODPARRS])
- ❌ N/A

### Digit Matrix ([DGMATRIX][DGMATRIX])
- ❌ N/A

### Palindromic Equivalence ([PALINDEQ][PALINDEQ])
- ❌ N/A


[EVENPSUM]: https://www.codechef.com/DEC20A/problems/EVENPSUM
[POSPREFS]: https://www.codechef.com/DEC20A/problems/POSPREFS
[HXOR]: https://www.codechef.com/DEC20A/problems/HXOR
[CALCULUS]: https://www.codechef.com/DEC20A/problems/CALCULUS
[STROPERS]: https://www.codechef.com/DEC20A/problems/STROPERS
[LCASQRT]: https://www.codechef.com/DEC20A/problems/LCASQRT
[DIVPERMS]: https://www.codechef.com/DEC20A/problems/DIVPERMS
[MODPARRS]: https://www.codechef.com/DEC20A/problems/MODPARRS
[DGMATRIX]: https://www.codechef.com/DEC20A/problems/DGMATRIX
[PALINDEQ]: https://www.codechef.com/DEC20A/problems/PALINDEQ


